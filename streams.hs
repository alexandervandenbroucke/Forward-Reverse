-- {-# LANGUAGE MultiParamTypeClasses #-}
-- {-# LANGUAGE FunctionalDependencies #-}
-- {-# LANGUAGE AllowAmbiguousTypes #-}
-- {-# LANGUAGE ScopedTypeVariables #-}
-- {-# LANGUAGE MonoLocalBinds #-}
-- {-# LANGUAGE UndecidableInstances #-}
-- {-# LANGUAGE FlexibleInstances #-}
-- {-# LANGUAGE RankNTypes #-}
-- {-# LANGUAGE ExistentialQuantification #-}
-- {-# LANGUAGE DeriveFunctor #-}
-- {-# LANGUAGE StandaloneDeriving #-}
-- {-# LANGUAGE FlexibleContexts #-}
-- {-# LANGUAGE OverlappingInstances #-}

module Streams where

-- import Data.Map
-- import Data.Array (Array,Ix,accumArray)
-- import Data.Array.IO
-- import Data.IORef
-- import Control.Monad (forM_)
-- import Control.Monad.State.Lazy
-- import Prelude hiding (lookup,map)


import Expressions

-- %%%
-- %%% differentiation at all degrees, using Streams
-- %%%
--
-- % infinite streams are easily shown to form a semiring:
-- % because (Stream d) is isomorphic to CW d (Stream d) !!!
--
-- infixr 5 :<
--
-- data Stream d = d :< Stream d
--
-- % isomorphism on the underlying data
--
-- cw_s :: CliffordWeil d (Stream d) -> Stream d
-- cw_s (CW d ds) = d :< ds
--
-- s_cw :: Stream d -> CliffordWeil d (Stream d)
-- s_cw (d :< ds) = CW d ds
--
-- instance Semiring d =Semigroup (Stream d) where
--   (x :< xs) <(y :< ys)   = (x `plus` y) :< (xs <ys)
--
-- instance Semiring d =Monoid (Stream d) where
--   mempty = zero :< mempty
--
-- instance Semiring d =SModule d (Stream d) where
--   d' `sact` (d :< ds) = (d' `times` d) :< (d' `sact` ds)
--
-- % alternative account of Stream d differential structure
--
-- two :: Semiring d =d
-- two = one `plus` one
--
-- instance Semiring d =Semiring (Stream d) where
--   zero  = cw_s zero
--   one   = cw_s one
--   xs `plus` ys   = xs <ys
--   (x :< xs) `times` (y :< ys)  = z :< (zs `plus` (two `sact` (xs `times` ys)))
--     where CW z zs = (CW x xs) `times` (CW y ys)
--
-- % hence, cf. general d-algebra structure on CW d e
--
-- instance Semiring d =SAlgebra d (Stream d) where
-- >
--   shom d = d :< zero
--
-- % hence, using the Dense instance of the Dirac structure,
-- % for e = Stream d, we obtain derivatives at all degrees:
--
-- forwardAll :: (Eq v, Semiring d) =(v -> d) -> Expr v -> v -> Stream d
-- forwardAll env exp v = d :< (ds v) where CW d ds = abstractAD env exp
--
